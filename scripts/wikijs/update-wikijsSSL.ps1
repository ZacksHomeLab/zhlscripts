<#
.Synopsis
    This script will renew WikiJS's Let's Encrypt certificate.

.DESCRIPTION
    This script will renew WikiJS's Let's Encrypt certificate.

.PARAMETER URL
    The URL of your WikiJS instance. If one isn't provided, the script will retrieve it from ConfigFile.

.PARAMETER Container
    The name of the docker container for WikiJS (run command 'docker container ls --all' to find the name)

.PARAMETER ServiceAccount
    The name of your service account for the WikiJS service (default is: WikiJS).

.PARAMETER LogFile
    The path of the log file to store the output of this script (default is: './Update-WikiJSSSL.log').

.EXAMPLE
    ./update-WikiJSSSL.ps1 -URL 'www.zhl.info' -Container 'wiki-wiki-1' -ServiceAccount 'wiki'

    The above will achieve the following:
        - Update Let's Encrypt SSL certificate for www.zhl.info
        - Change permissions of said files to service account 'docker'
        - Restart Docker Container 'wiki-wiki-1'
.NOTES
    Author - Zack Flowers
.LINK
    GitHub - https://github.com/ZacksHomeLab/
#>
[cmdletbinding()]
param (
    [parameter(Mandatory,
        Position=0,
        HelpMessage="What is the URL of your WikiJS website? (e.g., wiki.domain.com)")]
        [ValidateScript({$_ -Match "[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)"})]
    [string]$URL,

    [parameter(Mandatory,
        Position=1,
        HelpMessage="What is the name of the docker image for WikiJS?")]
        [ValidateNotNullOrEmpty()]
    [string]$Container,

    [parameter(Mandatory=$false,
        Position=2,
        helpMessage="Set the username that has permissions for your SSL Certs (e.g., docker)")]
        [ValidateNotNullOrEmpty()]
    [string]$ServiceAccount,

    [Parameter(Mandatory=$false, 
        Position=2)]
    [string]$LogFile = "./Update-WikiJSSSL.log"
)

begin {
    #region Variables
    $script:LOG_FILE = $LogFile

    # Incase someone gives http or https in their URL, remove it.
    if ($URL -match '^(http|https)://(.*)$') {
        $URL = ($URL).split('://')[-1]
    }
    
    # If someone gave a trailing '/' at the end of their URL, remove it.
    if ($URL[-1] -eq '/') {
        $URL = $URL.split('/')[0]
    }

    # Location of the cert files generated by certbot
    $LE_PRIVATE_KEY = "/etc/letsencrypt/live/$URL/privkey.pem"
    $LE_FULLCHAIN = "/etc/letsencrypt/live/$URL/fullchain.pem"
    $LE_CA_FILE = "/etc/letsencrypt/live/$URL/chain.pem"

    # Location to store the certificates in WikiJS's environment
    $WIKIJS_SSL_PRIVATE_KEY = "/opt/wiki/letsencrypt/privkey.pem"
    $WIKIJS_SSL_FULLCHAIN = "/opt/wiki/letsencrypt/fullchain.pem"
    $WIKIJS_SSL_CA_FILE = "/opt/wiki/letsencrypt/chain.pem"

    # This array will be used to validate if the below files actually exist. If they don't, the script will NOT run.
    $ITEMS_TO_VERIFY = @($LE_PRIVATE_KEY, $LE_FULLCHAIN, $LE_CA_FILE, $WIKIJS_SSL_PRIVATE_KEY, $WIKIJS_SSL_FULLCHAIN, $WIKIJS_SSL_CA_FILE)

    #region Exit Codse
    $exitcode_NotRoot = 10
    $exitcode_MissingCertbot = 12
    $exitcode_MissingChown = 13
    $exitcode_FailRunningCertbot = 14
    $exitcode_FailCompareHash = 15
    $exitcode_MissingSSLFiles = 16
    $exitcode_FailReplacePrivateKey = 17
    $exitcode_FailReplaceFullChain = 18
    $exitcode_FailReplaceCA = 19
    $exitcode_FailUpdatingOwnership = 20
    $exitcode_FailRestartingWikiJS = 21
    #endregion

    #region Functions
    function Write-Log {
        [CmdletBinding()]
        param (
            [Parameter(Mandatory, Position=0)]
            [ValidateNotNullOrEmpty()]
            [String]$Message,

            [Parameter(Mandatory=$false, Position=1)]
            [ValidateSet('Verbose', 'Info', 'Warning', 'Error')]
            [String]$EntryType = "Info",

            [parameter(Mandatory=$false, Position=2)]
            [ValidateNotNullOrEmpty()]
            [string]$Path = $script:LOG_FILE
        )
        
        begin {
            
            # Check if the log level an error or an error record was submitted
            if ($EntryType -eq 'Error') {
                $ErrorRecord = New-Object -TypeName System.Management.Automation.ErrorRecord -ArgumentList $Message, 'Unknown', 'NotSpecified', $null
            }
        }
        
        process {
            # Output to file
            $Line = "[$EntryType][$((Get-Date).toString('yyyy-MM-dd:hh-mm-ss'))], $Message"
            $Line | Out-File $Path -Append
            
            switch ($EntryType) {
                'Verbose'     { Write-Verbose -Message $Message }
                'Info'        { Write-Output $Message }
                'Warning'     { Write-Warning -Message $Message }
                'Error'       { Write-Error -ErrorRecord $ErrorRecord }
            }
        }
    }

    function Start-Command {
        [cmdletbinding(DefaultParameterSetName="default")]
        param (
            [parameter(Mandatory,
                Position=0,
                ValueFromPipelineByPropertyName)]
                [ValidateNotNullOrEmpty()]
            [string]$Name,
    
            [parameter(Mandatory=$false,
                Position=1,
                ValueFromPipelineByPropertyName)]
                [ValidateNotNullOrEmpty()]
            [object]$Arguments,
    
            [parameter(Mandatory=$false,
                ValueFromPipelineByPropertyName)]
                [ValidateScript({Test-Path $_})]
            [string]$WorkingDirectory,
    
            [parameter(Mandatory=$false)]
                [ValidateScript({
                    if ($PSVersionTable.Platform -eq "Unix") {
                        Throw "-LoadUserProfile cannot be used on Unix/Linux."
                    }
                })]
            [switch]$LoadUserProfile,
    
            [parameter(Mandatory,
                ValueFromPipelineByPropertyName,
                ParameterSetName="timer")]
                [ValidateRange(1, 600000)]
            [int]$Timer,
    
            [parameter(Mandatory=$false,
                ValueFromPipelineByPropertyName)]
                [ValidateScript({
                    if ($PSVersionTable.Platform -eq "Unix") {
                        Throw "-Verb cannot be used on Unix/Linux."
                    }
                })]
            [string]$Verb,
    
            [parameter(Mandatory=$false)]
            [switch]$Passthru
        )
    
        begin {
            $FileName = (Get-Command -Name $Name -ErrorAction SilentlyContinue).Source
    
            # If we cannot find the provided FileName, this could be due to the user providing..
            # ..a command that is a PowerShell Alias (e.g., echo, history, cp)
            if ($null -eq $FileName -or $FileName -eq "") {
                
                # Source doesn't exist. Let's see if the provided command is a PowerShell command
                $getPSCommand = (Get-Command -Name $Name -ErrorAction SilentlyContinue)
    
                if ($null -eq $getPSCommand -or $getPSCommand -eq "") {
                    Throw "Start-Command: Could not find command $Name nor could we find its PowerShell equivalent."
                }
    
                # Stop the script if the command was found but it returned an alias. 
                # Sometimes, a command may not return a source but WILL return an alias. This will cause issues with incompatibility with..
                # ..parameters for said commands.
                #
                # Example commands that will not work: echo, history, and cd
                if ($getPSCommand.CommandType -eq 'Alias') {
                    Throw "Start-Command: This function does not support Aliases. Command $Name matches $($getPSCommand.ResolvedCommand.Name)."
                }
    
                # This function does not support Microsoft PowerShell commands.
                if ($getPSCommand.Source -like "Microsoft.PowerShell*") {
                    Throw "Start-Command: This function should only be used for Non-PowerShell commands (e.g., wget, touch, mkdir, etc.)"
                }
    
                # Retrieve the version of PowerShell and its location and replace $FileName with it
                $FileName = $PSVersionTable.PSEdition -eq 'Core' ? (Get-Command -Name 'pwsh').Source : (Get-Command -Name 'powershell').Source
                
                # Reconfigure Arguments to execute PowerShell
                $Arguments = "-noprofile -Command `"& {$($getPSCommand.ReferencedCommand.Name) $Arguments}`""
            }
    
            # Data Object will store all streams of data from our command
            $dataObject = [pscustomobject]@{
                Title        = $Name
                OutputStream = ''
                OutputData   = ''
                ErrorData    = ''
                ExitCode     = 0
            }
        }
        process {
    
            $processStartInfoProps = @{
                Arguments               = $null -ne $Arguments ? $Arguments : $null
                CreateNoWindow          = $true
                ErrorDialog             = $false
                FileName                = $FileName
                RedirectStandardError   = $true
                RedirectStandardInput   = $true
                RedirectStandardOutput  = $true
                UseShellExecute         = $false
                WindowStyle             = [System.Diagnostics.ProcessWindowStyle]::Hidden
                WorkingDirectory        = $PSBoundParameters.ContainsKey('WorkingDirectory') ? $WorkingDirectory : $PSScriptRoot
                Verb                    = $PSBoundParameters.ContainsKey('Verb') ? $Verb : $null
            }
    
            # This will Error on Unix/Linux Systems if property LoadUserProfile is added regardless if it's null or false.
            if ($PSBoundParameters.ContainsKey('LoadUserProfile')) {
                $processStartInfoProps.Add('LoadUserProfile', $LoadUserProfile)
            }
    
            try {
    
                $process = New-Object System.Diagnostics.Process
                $process.EnableRaisingEvents = $true
    
                $processStartInfo = New-Object System.Diagnostics.ProcessStartInfo -Property $processStartInfoProps
                $process.StartInfo = $processStartInfo
    
                # Register Process OutputDataReceived:
                #   This will create a background job to capture output data
                #   Reference: https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.standardoutput?redirectedfrom=MSDN&view=net-7.0#System_Diagnostics_Process_StandardOutput
                $outputEventParams = @{
                    InputObject = $process
                    SourceIdentifier = 'OnOutputDataReceived '
                    EventName = 'OutputDataReceived'
                    Action = {
                        param (
                            [System.Object]$sender,
                            [System.Diagnostics.DataReceivedEventArgs]$e
                        )
    
                        foreach ($data in $e.Data) { 
                            if ($null -ne $data -and $data -ne "") { 
                                $($data).Trim()
                            } 
                        }
                    }
                }
                $dataObject.OutputStream = Register-ObjectEvent @outputEventParams
    
                # Start the process/command
                if ($process.Start()) {
                    $process.BeginOutputReadLine()
                    $dataObject.ErrorData = $process.StandardError.ReadToEnd()
    
                    if ($PSCmdlet.ParameterSetName -eq 'timer') {
                        $process.WaitForExit($Timer) | Out-Null
                    } else {
                        $process.WaitForExit()
                    }
                }
                
                # Retrieve the exit code and the OutputStream Job
                $dataObject.ExitCode = $process.ExitCode
                $dataObject.OutputData = Receive-Job -id $($dataObject.OutputStream.id)
    
                [bool]$hasError = ($null -ne $($dataObject.ErrorData) -and $($dataObject.ErrorData) -ne "" -and $($dataObject.ExitCode) -ne 0) ? $true : $false
                [bool]$hasOutput = ($null -ne $($dataObject.OutputData) -and $($dataObject.OutputData) -ne "") ? $true : $false
    
                # Output the PSCustomObject if -Passthru is provided.
                if ($Passthru) {
                    if ($hasError) {
                        $dataObject.ErrorData = $($dataObject.ErrorData.Trim())
                    }
                    $dataObject
                } else {
    
                    if ($hasError) {
                        if ($($ErrorActionPreference) -ne 'Stop') {
                            Write-Error "Exit Code $($dataObject.ExitCode): $($dataObject.ErrorData.Trim())"
                        } else {
                            Throw "Exit Code $($dataObject.ExitCode): $($dataObject.ErrorData.Trim())"
                        }
                    }
    
                    if ($hasOutput) {
                        $($dataObject.OutputData)
                    }
                }
            }
            finally {
    
                # Cleanup
                $process.Close()
                Unregister-Event -SourceIdentifier $($dataObject.OutputStream.Name) -Force | Out-Null
                Remove-Job -Id $($dataObject.OutputStream.Id) -Force
            }
        }
    }

    function Test-WikiSSLFiles {
        <#
        .Synopsis
            This function will verify if you have all the necesasry SSL files for renewal.
        .DESCRIPTION
            This function will verify a given array of files and verify if said files will exist. The output will be true or false if you have everything.
        .PARAMETER Data
            The array of items to be validated.
        .EXAMPLE
            $URL = 'WikiJS.zackshomelab.com'
            $ITEMS_TO_VERIFY = @("/etc/letsencrypt/live/$URL/privkey.pem", "/etc/letsencrypt/live/$URL/fullchain.pem", "/etc/letsencrypt/live/$URL/chain.pem")
            
            Test-WikiSSLFiles -Data $ITEMS_TO_VERIFY
            
            The above will verify all the items within ITEMS_TO_VERIFY exist. If they exist, Test-ZHLBWSSLFiles will return True.
        .INPUTS
            System.Object[]
        .OUTPUTS
            Boolean
        #>
        [cmdletbinding()]
        param (
            [parameter(Mandatory)]
            [ValidateNotNullOrEmpty()]
            [System.Object[]]$Data
        )
    
        begin {
            $ITEMS_MISSING = @()
            $ITEM_MISSING = $null
            $Item = $null
        }
        process {
            # If any of our items fail validation, set Success to False
            $ITEMS_MISSING = foreach ($Item in $Data) {
                # Verify the item exists
                if (-not (Test-Path -Path $Item)) {
                    $Item
                }
            }
            # If ITEMS_MISSING is greater than 0, output what's missing
            if ($ITEMS_MISSING.count -gt 0) {
                Write-Warning "Test-WikiSSLFiles: You're missing the following items:"
                foreach ($ITEM_MISSING in $ITEMS_MISSING) {
                    Write-Warning "Test-WikiSSLFiles: Missing $ITEM_MISSING"
                }
            }   
        }
    }

    function Get-DifferentHashStatus {
        [cmdletbinding()]
        param (
            [parameter(Mandatory)]
            [string[]]$Source,

            [parameter(Mandatory)]
            [string[]]$Target
        )

        Begin {
            # Add source and target files together
            $files = ($Source + $Target)
        }
        process {

            # if we have different file hashes, this will return 1 (aka we have differences).
            # Otherwise, this will return 0 (aka we have no differences)
            (Get-FileHash -Path $files | 
                Select-Object -Property Path, Hash | 
                Group-Object -Property Hash | 
                Where-Object Count -eq 1).Count -as [bool]
        }
    }
    #endregion
    
    #region Pre-Reqs
    # Check if the user is root
    if ($PSVersionTable.Platform -eq "Unix") {
        if ((Start-Command -Name 'whoami') -ne "root") {
            Write-Log -EntryType Warning -Message "Code $exitcode_NotRoot`: You must run this script as root, stopping."
            Throw "Code: $exitcode_NotRoot"
        }
    }
    
    # Verify certbot is installed
    if (-not (Get-Command -Name 'certbot' -ErrorAction SilentlyContinue)) {
        Write-Log -EntryType Warning -Message "Code $exitcode_MissingCertbot`: Missing the certbot command, is it installed?"
        Throw "Code: $exitcode_MissingCertbot"
    }

    # Verify chown exists
    if (-not (Get-Command -Name 'chown' -ErrorAction SilentlyContinue)) {
        Write-Log -EntryType Warning -Message "Code $exitcode_MissingChown`: Missing the chown command. This is required to update SSL Certificate ownership."
        Throw "Code: $exitcode_MissingChown"
    }

    # Verify we have all the required SSL files
    Write-Log "Main: Verify if we have all the required files to run this script."
    try {
        Test-WikiSSLFiles -Data $ITEMS_TO_VERIFY -ErrorAction Stop
    } catch {
        Write-Log -EntryType Warning -Message "Code $exitcode_MissingSSLFiles`: You do not have the required files to utilize this script, stopping."
        Throw "Code: $exitcode_MissingSSLFiles"
    }
    #endregion

    # If we copied any SSL files, we'll need to restart WikiJS
    $needToCopy = $false
}

process {

    #region Renew SSL Certificate
    try {
        Write-Log "`nMain: Renewing SSL certificate with Certbot..."
        Start-Command -Name 'certbot' -Arguments 'renew' -ErrorAction Stop
    } catch {
        Write-Log -EntryType Warning -Message "Code $exitcode_FailRunningCertbot`: Failure running certificate due to error $_"
        Throw "Code: $exitcode_FailRunningCertbot"
    }
    #endregion


    #region Verify if SSL Certificate renewed

    # Determine if we need to update SSL files
    try {

        Write-Log "`nMain: Coparing hash values with LE SSL files with WikiJS SSL Files..."
        # Note: ResolvedTarget is following the symlink
        $source = $(Get-Item -Path $LE_PRIVATE_KEY).ResolvedTarget, `
            $(Get-Item -Path $LE_FULLCHAIN).ResolvedTarget, `
            $(Get-Item -Path $LE_CA_FILE).ResolvedTarget
        
        $target = $WIKIJS_SSL_PRIVATE_KEY, $WIKIJS_SSL_FULLCHAIN, $WIKIJS_SSL_CA_FILE

        # This will return true if we have different hash values
        $needToCopy = Get-DifferentHashStatus -Source $source -Target $target -ErrorAction Stop

    } catch {
        Write-Log -EntryType Warning -Message "Code $exitcode_FailCompareHash`: Failure comparing hash values due to error $_"
        Throw "Code: $exitcode_FailCompareHash"
    }
    #endregion

    #region Replace WikiJS's files
    if ($needToCopy) {
        try {
            Write-Log "`nMain: Replacing $WIKIJS_SSL_PRIVATE_KEY with $LE_PRIVATE_KEY"
            Start-Command -Name 'cp' -Arguments "--dereference --force --update $LE_PRIVATE_KEY $WIKIJS_SSL_PRIVATE_KEY" -ErrorAction Stop
        } catch {
            Write-Log -EntryType Warning -Message "Code $exitcode_FailReplacePrivateKey`: Failed replacing $WIKIJS_SSL_PRIVATE_KEY with $LE_PRIVATE_KEY."
            Throw "Code: $exitcode_FailReplacePrivateKey"
        }
        
        try {
            Write-Log "Main: Replacing $LE_FULLCHAIN with $LE_FULLCHAIN"
            Start-Command -Name 'cp' -Arguments "--dereference --force --update $LE_FULLCHAIN $WIKIJS_SSL_FULLCHAIN" -ErrorAction Stop
        } catch {
            Write-Log -EntryType Warning -Message "Code $exitcode_FailReplaceFullChain`: Failed replacing $WIKIJS_SSL_FULLCHAIN with $LE_FULLCHAIN."
            Throw "Code: $exitcode_FailReplaceFullChain"
        }
    
        try {
            Write-Log "Main: Replacing $WIKIJS_SSL_CA_FILE with $LE_CA_FILE"
            Start-Command -Name 'cp' -Arguments "--dereference --force --update $LE_CA_FILE $WIKIJS_SSL_CA_FILE" -ErrorAction Stop
        } catch {
            Write-Log -EntryType Warning -Message "Code $exitcode_FailReplaceCA`: Failed replacing $WIKIJS_SSL_CA_FILE with $LE_CA_FILE."
            Throw "Code: $exitcode_FailReplaceCA"
        }
    
        #region Change ownership of WikiJS's SSL files
        try {
            #Write-Log "`nMain: Changing ownership of WikiJS's SSL files to service account $ServiceAccount."
            Start-Command -Name 'chown' -Arguments "$ServiceAccount $WIKIJS_SSL_PRIVATE_KEY $WIKIJS_SSL_FULLCHAIN $WIKIJS_SSL_CA_FILE" -ErrorAction Stop
        } catch {
            Write-Warning "Code $exitcode_FailUpdatingOwnership`: Failed changing ownership of WikiJS's SSL files. Due to error $_"
            Throw "Code: $exitcode_FailUpdatingOwnership"
        }
        #endregion

        #region Restart WikiJS
        try {
            Write-Log "`nMain: Restart WikiJS for the new SSL certificates."
            Start-Command -Name 'docker' -Arguments "container restart $Container" -ErrorAction Stop
        } catch {
            Write-Log -EntryType Warning -Message "Code $exitcode_FailRestartingWikiJS`: Failure restarting WikiJS due to error $_"
            exit $exitcode_FailRestartingWikiJS
        }
        #endregion
    } else {
        Write-Log "Main: All of our files have matching hash values. No need to do anything at this point."
    }
}
